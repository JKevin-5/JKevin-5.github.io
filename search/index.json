[{"content":"MyBatis-Plus 首先是，What\u0026amp;Why\nMyBatis  MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。——引自MyBatis的官网\n 介绍中清楚的写到MyBatis需要通过创建XML或注解的方式去配置，非常的繁琐，如下。\n1 2 3  \u0026lt;select id=\u0026#34;selectPerson\u0026#34; parameterType=\u0026#34;int\u0026#34; resultType=\u0026#34;hashmap\u0026#34;\u0026gt; SELECT * FROM PERSON WHERE ID = #{id} \u0026lt;/select\u0026gt;   如果是习惯了之前使用JPA的方式开发的朋友会怀念JPA中简短的操作，只需要在Repository中继承JpaRepository就可以实现简单的增删改查的功能，而这些在MyBatis-Plus中实现了。\nMyBatis-Plus  MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。——引自MyBatis-Plus官网\n 介绍中有几个点需要注意，一个是增强不做改变，一个是简化开发。\n增强不做改变是因为引入之后不会使得之前搭配MyBatis设置的xml或mapper的开发方式出现错误；\n简化开发是启动自动注入基本的CRUD、支持Lambda形式调用，甚至还有对sql性能的监测等等，都是让人非常激动的特性。相信懒汉总是有办法让自己吃饱。\n二、搭配请求场景的一些使用   MyBatis的初始化，详细见官网\n  对于一个字段的多个值进行搜索\n1 2 3 4 5 6 7 8 9 10  /** * 例如以一个或多个基金名称来搜索数据 * @Param：List * @Return：List */ @GetMapping(\u0026#34;/funds\u0026#34;) public List\u0026lt;FundInfo\u0026gt; getFundInfoByName(@RequestBody List\u0026lt;String\u0026gt; fundNameList){ List\u0026lt;FundInfo\u0026gt; fundList = fundInfoMapper.selectBatchIds(fundNameList); return fundInfoList; }     模糊搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * 例如对基金名称、基金编号进行模糊搜索，可考虑默认返回的数据条数Limit，使用场景下拉选择 * @Param:String * @Return:List */ @GetMapping(\u0026#34;/fund/{name}\u0026#34;) public List\u0026lt;FundToday\u0026gt; getFundInfoByNameOrCode(@PathVariable(\u0026#34;name\u0026#34;) String fundName){ // 创建一个MyBatis-Plus的SQL构造器 \tQueryWrapper queryWrapper = new QueryWrapper\u0026lt;FundToday\u0026gt;(); // like用来做模糊匹配 \tqueryWrapper.like(\u0026#34;name\u0026#34;,fundName); // or这边简单明了 \tqueryWrapper.or(); queryWrapper.like(\u0026#34;fund_code\u0026#34;,fundName); // 关于order的顺序调用这块比较不那么灵活，要可变配置的话可以看一下其他的方法 \tqueryWrapper.orderByDesc(\u0026#34;fund_code\u0026#34;); // 最后加上对条数的限制 \tqueryWrapper.last(\u0026#34;limit 5\u0026#34;); return fundTodayMapper.selectList(queryWrapper); }     分页查询（简单实现）\n首先要创建一个configuration配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * @author : Jkevin * @version 1.0 * @date : 2022/4/17 下午5:52 * @describtion: */ @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } }   其次才是创建对应的逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * @Author JKevin * @Description: 分页查询功能 * @Date 2022/4/17 * @Param * @return **/ @PostMapping(\u0026#34;/fund/all\u0026#34;) public IPage\u0026lt;FundToday\u0026gt; getAllFundInfo(@RequestBody FundPageDTO fundPageDTO){ QueryWrapper\u0026lt;FundToday\u0026gt; wrapper = new QueryWrapper\u0026lt;\u0026gt;(); // 在此处可以写前端传入的condition查询条件部分内容 \tif ( StringUtils.isNotEmpty(fundPageDTO.getFilter()) ){ wrapper.like(\u0026#34;name\u0026#34;,fundPageDTO.getFilter()); wrapper.or(); wrapper.like(\u0026#34;fund_code\u0026#34;,fundPageDTO.getFilter()); } // 此处是为了前台表格可以实现顺序、逆序的切换 \tif ( StringUtils.isNotEmpty(fundPageDTO.getFilterName()) \u0026amp;\u0026amp; StringUtils.isNotEmpty(fundPageDTO.getFilterType().toString())){ // orderBy 会更加灵活 \twrapper.orderBy(true,fundPageDTO.getFilterType(),fundPageDTO.getFilterName()); } // 可以选择直接返回page或者是转换为list返回 \tPage\u0026lt;FundToday\u0026gt; page = new Page\u0026lt;\u0026gt;(fundPageDTO.getCurrent(),fundPageDTO.getSize()); IPage\u0026lt;FundToday\u0026gt; fundTodayIPage = fundTodayMapper.selectPage(page,wrapper); return fundTodayIPage; }     简单的增删改查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // 查 @GetMapping(\u0026#34;/user/{userId}\u0026#34;) public List\u0026lt;Possession\u0026gt; findPossessionsByUserId(@PathVariable(\u0026#34;userId\u0026#34;) String userId){ QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(\u0026#34;userId\u0026#34;,userId); return possessionMapper.selectList(queryWrapper); } // 增 @PostMapping public int addPossession(@RequestBody Possession possession){ return possessionMapper.insert(possession); } // 删 @DeleteMapping public int deletePossession( @RequestParam(\u0026#34;id\u0026#34;) int id ,@RequestParam(\u0026#34;userId\u0026#34;) String userId){ QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(\u0026#34;id\u0026#34;,id); queryWrapper.eq(\u0026#34;userId\u0026#34;,userId); return possessionMapper.delete(queryWrapper); } // 改 @PutMapping public int updatePossession(@RequestBody Possession possession){ QueryWrapper queryWrapper = new QueryWrapper(); queryWrapper.eq(\u0026#34;id\u0026#34;,possession.getId()); queryWrapper.eq(\u0026#34;userId\u0026#34;,possession.getUserId()); return possessionMapper.update(possession,queryWrapper); }     其他的例子可以看：官网示例地址 ，或者去查找对应需求的博客，不建议直接食用官网介绍，个人比较愚钝看不太明白🫠。\n  三、总结 写到总结的时候又是瘫了半天才开始写的，感觉自己写了很多大家都懂的东西，最多的还是对自己的近期的学习总结。如果有帮助到大家是极好的。\n其实总结知识并输出的时间比学习的时间会多出好多，可能一天学习的量能输出四五个散装的知识点，有时候你在coding的时候，可能不用去看API文档就可以预料到该作者应该会怎么写，尝试去利用联想进行coding，这个可能就是一个很大的进步了。\nTake care gays，Keep Moving。\n","date":"2022-04-20T00:00:00Z","permalink":"http://www.jkevinspark.com/p/20220420/","title":"【MySql】结合请求场景的Mybatis-Plus应用"},{"content":"文档的获取途径可以通过GitHub链接下载。\n命名风格 所有命名  所有编程相关命名不能以下划线或美元符号_$开始或结束； 所有编程相关命名严禁使用拼音与英文混合的方式，也不允许直接使用中文的方式（按照正确的英文拼写和语法）； 代码和注释中避免使用任何人类语言中种族歧视或侮辱性词语； 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用完整的单词组合来表达； 如果模块、接口、类、方法使用了设计模式，在命名时要体现出具体模式。  类、接口   类名使用UpperCamelCase风格（使用大写英文字母打头）；\n  抽象类命名使用Abstract或Base开头；\n  异常类命名使用Exception结尾；\n  测试类命名以它要测试的类的名称开始，以Test结尾；\n  接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释*；\n  接口和实现类的命名规则：\n  对于Service和DAO类，内部的实现类用Impl的后缀与接口区别；\nCacheServiceImpl实现CacheService接口\n  如果是形容能力的接口名称，取对应的形容词为接口名（通常是-able结尾的形容词）。\nAbstractTranslator实现Translatable\n    枚举类*名带上Enum后缀，枚举成员名称需要全大写，单词间下划线隔开。\n  方法、参数、成员变量、局部变量、常量、数组  方法名、参数名、成员变量、局部变量使用lowerCamelCase风格（使用小写英文字母打头）； 常量命名应该全部大写，单词间用下划线隔开； 类型与中括号紧挨相连来定义数组 Type[] arrayList； 在常量与变量命名时，表示类型的名词放在词尾，以提高辨识度nameList/startTime/workQueue；  包名  包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。  各层命名规约   Service/DAO层方法命名规约：\n 获取单个对象的方法：get为前缀 获取多个对象的方法：list为前缀，复数结尾，如listObjects 获取统计值的方法：count为前缀 插入的方法：save/insert做前缀 删除的方法：remove/delete做前缀 修改的方法：update做前缀    领域模型命名规约\n 数据对象：xxxDO，xxx为数据表名 数据传输对象：xxxDTO，xxx为业务领域相关的名称 展示对象：xxxVO，xxx一般为网页名称 POJO是DO/DTO*/BO*/VO*的统称，禁止命名成xxxPOJO    代码格式 大括号、小括号   如果大括号内为空，简洁地写成{}即可，大括号中间无需换行和空格；\n  如果非空代码块，则：\n1 2 3 4 5 6 7 8  public static void main(String[] args) {// 左边大括号前加空格切不换行，左大括号后换行 if (xxx == xx) { xxxxx // 右大括号前换行，右大括号后有else，else在同一行，不用换行 } else { xxxxx } // 在右大括号后直接结束，则必须换行 }     if/for/while/switch/do等保留字与左右括号之间都必须加空格；\n  左小括号和右边相邻字符之间不需要空格；\n  右小括号和左边相邻字符之间不需要空格；\n  左大括号前要加空格；\n  运算符  任何二目、三目运算符的左右两边都要加一个空格（包括赋值运算符=、逻辑运算符\u0026amp;\u0026amp;、加减乘除符号等；  其它   采用4个空格缩进，禁止使用tab字符（可以在ide进行tab缩进的设置）；\n  注释的双斜线与注释内容之间有且仅有一个空格；\n  在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开；\n  单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则：\n 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进； 运算符与下文一起换行； 方法调用的点符号与下文一起换行； 方法调用中的多个参数需要换行时，在逗号后进行； 在括号前不要换行。    方法参数在定义和传入时，多个参数逗号后面必须加空格；\nmethod(arg1, arg2, arg3);\n  单个方法总行数不超过80行；\n  没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐；\n   未完待续\u0026hellip;.\n总结 后续有空再陆陆续续添加mysql相关、Java相关规约补充，很多规约没有形成文档的时候都是一团乱麻。好比看了阿里的开发手册后我才发现公司框架中很多地方是遵循了这个规约但是并没有文档可以参考，大部分的编码风格都是靠项目初期整理或搭建框架的“大佬“定下的主基调，后续的人有的遵循着开发有的就另辟自己的风格，导致项目中很多东西都很难理解和看懂，冗余以及效率上的问题时有发生。\n最近有在听《组织进化论》的播客节目，硬知识干货不少，硬广爸爸飞书的推广也是很足，导致现在让我感觉不使用飞书就不是好企业的幻觉。但是有一点特别赞同的，不管是哪个工作时期，工作中留下文档是很必要的，不管是让别人知道你干了些什么，或者是你会干什么，更或者是你离职了之后后面的人如何接手你的工作，都是一个很好的参考，对于你自己的复盘也是一个很棒的资料。推荐大家积极留下文档，但不限于形式。\n","date":"2022-04-10T00:00:00Z","permalink":"http://www.jkevinspark.com/p/20220410/","title":"【Java】阿里Java开发手册-部分总结（一）"},{"content":" 最主要的目的是为了实现定时的将当日基金数据爬到自己的数据库中，且集成日志管理、定时任务等。\n 一、crontab——Linux自带定时任务管理 crontab有几点好处：\n 随着系统的开关而开关，重启自动开启任务，不用操心服务器状态； crontab支持多种的脚本启动； 如果语法没有写对的情况下保存会有相应的报错。  更多有关crontab定时任务的设定的可以参考工具网站，切记选择Linux。\n1 2 3 4 5 6 7 8 9 10  # crontab 定时任务清单查看 crontab -l # crontab 定时任务清单编写 crontab -e # python脚本设置 # 每周1-5的14点和12点执行 0 12，14 * * 1-5 python /home/crontab/demo.py # shell脚本设置 # 在 凌晨00:10运行 10 0 * * * /home/swz/aa.sh   二、Linux修改时区  使用timedatectl查看当前时区； 更改时区设定前可以先搜索一下时区列表timedatectl list-timezones； 默认时区可以设置为上海sudo timedatectl set-timezone Asia/Shanghai。  三、切换python版本   Linux的命令行软链接地址为：/usr/bin；\n  centos7默认带有python2.7以及python3.6，默认python命令是指向的python2.7；\n  如何修改python指令的默认指向；\n1 2 3 4  # 首先删除之前已有的软链接 rm /usr/bin/python # 创建新的软链接到python3.6 ln -s /usr/bin/python3.6 /usr/bin/python     需要注意点是，只切换了python的版本是不够的，pip可能还是指向的之前的2.7版本，两个版本需要一致。\n  四、Python的日志编写  日志只要声明了，logging相关的语句会自动的写入本地文件； 本地文件的名称和地址以下默认为日期，因为是追加方式写入，一天内启动多次也只会产生一个文件，后续可以采用另一个定时任务去删除log文件，up to u； logging中的配置，level是最低输出的log级别，跟spring中使用slfj、lombok的log是一样的，如果我没记错的话。默认为warning，切记，logging.INFO这个需要大写； 更多有关python日志的内容可以参考网站。  五、总结 脚本并不稳定，且不是任何的错误都能跟java一样能捕捉得到，所以需要不断的测试，java的相关知识也需要慢慢的产出。 立flag，从本周起一周至少更新两篇post。\n","date":"2022-04-04T00:00:00Z","permalink":"http://www.jkevinspark.com/p/20220404/","title":"如何在Linux上使用定时任务执行python脚本"},{"content":"Apple IPPAWARDS比赛  随意挑选了几张照片参加了这个比赛，大概率是去凑了个分母，但是还是蛮开心的Deadline：2022-03-31\n参赛链接\n 夜晚的厦门  周五晚上下班就直接冲岛内，逛了一晚上\n ","date":"2022-03-05T00:00:00Z","image":"http://www.jkevinspark.com/p/20220304/p8_hudcf2eff898605e98496bc884ba2dd024_4019200_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jkevinspark.com/p/20220304/","title":"Pictures"}]